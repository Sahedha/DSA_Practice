# Insert an Adjacent Duplicate for All Occurrences of a Given Element  

### 📌 Problem Statement  
You are given an array `arr[]` of size `n` and an integer `k`.  
The task is to insert a **duplicate of `k` adjacent to its every occurrence**.  
Since the array size must remain the same, **truncate extra elements from the back**.  

---

### 🔍 Examples  

#### Example 1:  
**Input:**  
arr = [1, 0, 2, 3, 0, 4, 5, 0], k = 0

**Output:**  
[1, 0, 0, 2, 3, 0, 0, 4]

**Explanation:**  
- Insert duplicates of `0` next to each occurrence.  
- After modification: `[1, 0, 0, 2, 3, 0, 0, 4, 5, 0, 0]`.  
- Truncate to original size `n=8`: `[1, 0, 0, 2, 3, 0, 0, 4]`.  

---

#### Example 2:  
**Input:**  
arr = [7, 5, 8], k = 8

**Output:**  
[7, 5, 8]

**Explanation:**  
- Insert duplicate of `8`: `[7, 5, 8, 8]`.  
- Truncate to size `n=3`: `[7, 5, 8]`.  

---

### ⚙️ Constraints  
- `1 ≤ n ≤ 10^5`  
- `0 ≤ arr[i], k ≤ 10^6`  

---

### 🧠 Approach  

1. **Count occurrences of `k`** in the array.  
   - Each occurrence will need one duplicate.  

2. **Work from the end (right-to-left):**  
   - Use two pointers:  
     - `curr` → points to the current element (from end).  
     - `write_idx` → points where to write elements after duplication.  

3. **Shift elements carefully:**  
   - Place `arr[curr]` at `arr[write_idx]` (if within bounds).  
   - If `arr[curr] == k`, insert an extra `k` at `arr[write_idx - 1]`.  

4. **Truncate extra elements automatically** since we overwrite from the back.  

This method avoids shifting all elements multiple times, making it **efficient**.  

---

### 💻 Code (Java)  

```java
import java.util.*;

class Solution {

    // Function to insert adjacent duplicates of k
    static int[] duplicateK(int[] arr, int k) {
        int n = arr.length;
        
        // Count total occurrences of k
        int cnt = count(arr, k);

        // Write index (beyond original size due to duplicates)
        int write_idx = n + cnt - 1;
        int curr = n - 1;

        while (curr >= 0 && write_idx >= 0) {
            
            // Place current element in its position (if within bounds)
            if (write_idx < n)
                arr[write_idx] = arr[curr];

            write_idx--;

            // If element == k, duplicate it
            if (arr[curr] == k) {
                if (write_idx < n)
                    arr[write_idx] = k;
                write_idx--;
            }

            curr--;
        }
        return arr;
    }

    // Helper: count occurrences of num
    static int count(int[] arr, int num) {
        int ans = 0;
        for (int i : arr)
            if (i == num)
                ans++;
        return ans;
    }
}
```
---
### **⏳ Time & Space Complexity**
## Time Complexity: O(n)

We scan the array once to count occurrences.

Another pass from right to left to rearrange elements.

## Space Complexity: O(1)

No extra space used (in-place modification).

Only variables and counters are used.

✅ Efficient & Optimal: Works in-place and meets the constraints up to 10^5 elements.
