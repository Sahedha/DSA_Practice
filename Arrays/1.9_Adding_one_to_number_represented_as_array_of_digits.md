# ➕ Adding One to a Number Represented as an Array

## 📜 Problem Statement
You are given a **non-negative integer** (without leading zeros) represented as an array `arr[]`,  
where **each element is a single digit** and **most significant digit is at index 0**.  
Your task is to **add 1** to the number and return the new array representation.

The change must be **in-place** if possible, but for cases where the array size increases  
(e.g., `999` → `1000`), create a new array/vector.

---

## 🧩 Examples

### Example 1
**Input:**  
`arr = [5, 6, 7, 8]`  
**Output:**  
`[5, 6, 7, 9]`  
**Explanation:**  
5678 ➡️ 5678 + 1 = **5679**

---

### Example 2
**Input:**  
`arr = [9, 9, 9]`  
**Output:**  
`[1, 0, 0, 0]`  
**Explanation:**  
999 ➡️ 999 + 1 = **1000** (requires new leading digit)

---

## 💡 Constraints
- `1 ≤ arr.size() ≤ 10^6`  
- `0 ≤ arr[i] ≤ 9`

---

## 🚀 Approach

### 1️⃣ Start from the Last Digit
We begin adding 1 from the last index (units place).

### 2️⃣ Handle Carry from 9
If a digit is `9`, adding 1 turns it into `0` and we carry over to the previous digit.

### 3️⃣ Special Case: All 9's
If **all digits** are 9, we will need a new array with size `n+1`  
where the first digit is `1` and the rest are `0`.

---

### 📝 Steps
1. Start from index `n-1` (last digit).  
2. While the digit is `9`, set it to `0` and move to the left.  
3. If we finish the loop and all were `9`s, create a new array with `1` at the start and `0` everywhere else.  
4. Otherwise, simply increment the first non-9 digit and keep the rest unchanged.

---

## 📦 Code (Java)

```java
class Solution {
    // Function for adding one to the number represented by the array
    Vector<Integer> addOne(int[] arr) {
        int n = arr.length;
        int i = n - 1;
        
        // Step 1: Handle carry if digits are 9
        while (i >= 0 && arr[i] == 9) {
            arr[i--] = 0;
        }
        
        // Step 2: All digits were 9
        if (i < 0) {
            Vector<Integer> v1 = new Vector<>(n + 1);
            v1.add(1);
            for (int j = 0; j < n; j++) {
                v1.add(arr[j]);
            }
            return v1;
        }
        // Step 3: Increment the non-9 digit
        else {
            arr[i]++;
        }
        
        // Step 4: Convert to Vector for return
        Vector<Integer> v1 = new Vector<>(n);
        for (int j = 0; j < n; j++) {
            v1.add(arr[j]);
        }
        return v1;
    }
}


⏱ Complexity Analysis
Time Complexity: O(n) ⏳ — We may touch each digit once in the worst case (all 9's).

Space Complexity: O(1) 🪶 — No extra space except the result vector (constant extra space if no new digit).

📌 Key Points
✅ Works for both small and very large numbers represented as arrays.

✅ Handles carry propagation properly.

✅ Creates a new number if the size increases (e.g., 999 → 1000).

✅ Works in in-place fashion if possible.

✨ Tip: This is a classic carry-handling problem and often appears in interview coding rounds.
