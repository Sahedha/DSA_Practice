# Third Largest Element in Array

**Difficulty:** Easy  
**Accuracy:** 45.04%  
**Average Time:** 15 min  

---

## Problem Statement
Given an array `arr[]` of positive integers, find the **third largest element** in it.  
If the third largest element is not found (i.e., array has less than 3 distinct elements), return `-1`.

---

## Examples

### Example 1
**Input:**  
arr[] = [2, 4, 1, 3, 5]

**Output:**  
3

**Explanation:**  
The largest is `5`, second largest is `4`, and the third largest is `3`.

---

### Example 2
**Input:**  
arr[] = [10, 2]

**Output:**  
-1

**Explanation:**  
There are less than three elements, so the third largest element cannot be determined.

---

## Approach

We can solve this in **one pass** through the array by keeping track of:
- `fL` → first largest  
- `sL` → second largest  
- `tL` → third largest  

All are initialized to `-1` (since elements are **positive integers**).

**Steps:**
1. Iterate through each element:
   - If the current element is **greater than** `fL`:
     - Move `sL` to `tL`  
     - Move `fL` to `sL`  
     - Update `fL` with current element  
   - Else if the current element is **greater than** `sL`:
     - Move `sL` to `tL`  
     - Update `sL` with current element  
   - Else if the current element is **greater than** `tL`:
     - Update `tL` with current element  

2. Return `tL`.

---

## Code Implementation (Java)

```java
class Solution {
    int thirdLargest(int arr[]) {
        int n = arr.length;
        int fL = -1, sL = -1, tL = -1;

        for (int i = 0; i < n; i++) {
            if (arr[i] > fL) {
                // Shift down the values
                tL = sL;
                sL = fL;
                fL = arr[i];
            } else if (arr[i] > sL) {
                tL = sL;
                sL = arr[i];
            } else if (arr[i] > tL) {
                tL = arr[i];
            }
        }
        return tL;
    }
}
Dry Run Example
Input:
arr = [2, 4, 1, 3, 5]

Step	Current Element	fL	sL	tL	Action Taken
1	2	2	-1	-1	New largest found
2	4	4	2	-1	New largest found
3	1	4	2	1	New third largest found
4	3	4	3	2	New second largest found
5	5	5	4	3	New largest found

Output: 3

Time Complexity
O(n) → Single traversal of the array.

Space Complexity
O(1) → Only a few variables used.

Key Points
Works in a single pass for efficiency.

Uses constant space.

Returns -1 when fewer than 3 elements exist.
