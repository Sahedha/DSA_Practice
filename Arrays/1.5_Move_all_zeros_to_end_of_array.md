# 🚀 Move All Zeroes to End

**Difficulty:** 🟢 Easy  
**Accuracy:** 📊 45.51%  

---

## 📜 Problem Statement
You are given an array `arr[]` of **non-negative integers**.  
Your task is to **move all the zeros** in the array to the **right end** while maintaining the **relative order** of the non-zero elements.  

⚠️ **Note:** The operation must be **in-place** (no extra array allowed).

---

## 📂 Examples

**Example 1**  
Input:  
arr[] = [1, 2, 0, 4, 3, 0, 5, 0]

Output:  
[1, 2, 4, 3, 5, 0, 0, 0]

✅ **Explanation:** There are three `0`s that are moved to the end.

---

**Example 2**  
Input:  
arr[] = [10, 20, 30]

Output:  
[10, 20, 30]

✅ **Explanation:** No change as there are no `0`s.

---

**Example 3**  
Input:  
arr[] = [0, 0]

Output:  
[0, 0]

✅ **Explanation:** All are zeros, so the array remains the same.

---

## 📏 Constraints
- `1 ≤ arr.size() ≤ 10^5`  
- `0 ≤ arr[i] ≤ 10^5`

---

## 🛠 Approach
1. **Count pointer:** Maintain a variable `count` to track the index where the next non-zero element should be placed.  
2. **First pass:** Traverse the array and copy all **non-zero** elements to the front (using `count`).  
3. **Second pass:** Fill the rest of the array with zeros starting from `count` to the end.  
4. **In-place:** No extra array is used — everything happens within the same array.

---

## 💻 Code Implementation (Java)
```java
class Solution {
    void pushZerosToEnd(int[] arr) {
        int count = 0;
        for(int i = 0; i < arr.length; i++) {
            if(arr[i] != 0) {
                arr[count++] = arr[i];
            }
        }
        while(count < arr.length) {
            arr[count++] = 0;
        }
    }
}


⏱ Time Complexity
O(n) — We traverse the array twice (but both passes are linear).

💾 Space Complexity
O(1) — No extra space is used.

✨ Key Points
✔ Maintains the relative order of non-zero elements.

✔ Works in-place without extra space.

✔ Handles edge cases like all zeros or no zeros efficiently.

🎯 Summary
This problem teaches in-place array manipulation — a crucial technique for optimizing space in algorithms.
Mastering such problems improves skills in two-pointer techniques and efficient iteration.

---
