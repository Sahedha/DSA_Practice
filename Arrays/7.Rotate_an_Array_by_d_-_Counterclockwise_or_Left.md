# 🔄 Rotate Array

**Difficulty:** Medium  
**Accuracy:** 37.06%  

---

## 📜 Problem Statement
Given an array `arr[]`. Rotate the array to the **left** (counter-clockwise direction) by `d` steps, where `d` is a positive integer.  
The change must be done **in-place**.  
Consider the array as **circular**.

---

## 💡 Examples

**Example 1:**
Input: arr[] = [1, 2, 3, 4, 5], d = 2
Output: [3, 4, 5, 1, 2]
Explanation: Rotating by 2 elements → 3 4 5 1 2


**Example 2:**
Input: arr[] = [2, 4, 6, 8, 10, 12, 14, 16, 18, 20], d = 3
Output: [8, 10, 12, 14, 16, 18, 20, 2, 4, 6]
Explanation: Rotating by 3 elements → 8 10 12 14 16 18 20 2 4 6


**Example 3:**
Input: arr[] = [7, 3, 9, 1], d = 9
Output: [3, 9, 1, 7]
Explanation: 9 rotations → effectively 1 rotation (9 % 4 = 1)


---

## 📏 Constraints
- 1 ≤ arr.size(), d ≤ 10⁵  
- 0 ≤ arr[i] ≤ 10⁵  

---

## 🛠️ Approach
We can rotate the array **in-place** using the **Reversal Algorithm**:

1. **Step 1:** Reverse the first `d` elements.  
2. **Step 2:** Reverse the remaining `n - d` elements.  
3. **Step 3:** Reverse the entire array.

📌 **Why it works?**  
Reversing segments and then the whole array rearranges the elements into their rotated positions without using extra space.

---

## 💻 Code Implementation
```java
// User function Template for Java

class Solution {
    // Function to rotate an array by d elements in counter-clockwise direction.
    static void rotateArr(int arr[], int d) {
        int n = arr.length;
        d %= n; // handle cases where d > n
        
        // Reverse the first part
        reverse(arr, 0, d - 1);
        
        // Reverse the second part
        reverse(arr, d, n - 1);
        
        // Reverse the whole array
        reverse(arr, 0, n - 1);
    }
    
    // Helper function to reverse an array segment
    static void reverse(int[] arr, int start, int end) {
        while (start < end) {
            int temp = arr[start];
            arr[start] = arr[end];
            arr[end] = temp;
            start++; 
            end--;
        }
    }
}


⏳ Complexity Analysis
Time Complexity: O(n) — Each element is swapped at most twice.

Space Complexity: O(1) — In-place rotation, no extra space used.

🧠 Key Takeaways
✅ Use modulo to avoid unnecessary rotations (d %= n).
✅ The Reversal Algorithm is efficient for array rotations.
✅ Works for large arrays within the given constraints.
