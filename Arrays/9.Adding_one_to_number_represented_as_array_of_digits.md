# â• Adding One to a Number Represented as an Array

## ğŸ“œ Problem Statement
You are given a **non-negative integer** (without leading zeros) represented as an array `arr[]`,  
where **each element is a single digit** and **most significant digit is at index 0**.  
Your task is to **add 1** to the number and return the new array representation.

The change must be **in-place** if possible, but for cases where the array size increases  
(e.g., `999` â†’ `1000`), create a new array/vector.

---

## ğŸ§© Examples

### Example 1
**Input:**  
`arr = [5, 6, 7, 8]`  
**Output:**  
`[5, 6, 7, 9]`  
**Explanation:**  
5678 â¡ï¸ 5678 + 1 = **5679**

---

### Example 2
**Input:**  
`arr = [9, 9, 9]`  
**Output:**  
`[1, 0, 0, 0]`  
**Explanation:**  
999 â¡ï¸ 999 + 1 = **1000** (requires new leading digit)

---

## ğŸ’¡ Constraints
- `1 â‰¤ arr.size() â‰¤ 10^6`  
- `0 â‰¤ arr[i] â‰¤ 9`

---

## ğŸš€ Approach

### 1ï¸âƒ£ Start from the Last Digit
We begin adding 1 from the last index (units place).

### 2ï¸âƒ£ Handle Carry from 9
If a digit is `9`, adding 1 turns it into `0` and we carry over to the previous digit.

### 3ï¸âƒ£ Special Case: All 9's
If **all digits** are 9, we will need a new array with size `n+1`  
where the first digit is `1` and the rest are `0`.

---

### ğŸ“ Steps
1. Start from index `n-1` (last digit).  
2. While the digit is `9`, set it to `0` and move to the left.  
3. If we finish the loop and all were `9`s, create a new array with `1` at the start and `0` everywhere else.  
4. Otherwise, simply increment the first non-9 digit and keep the rest unchanged.

---

## ğŸ“¦ Code (Java)

```java
class Solution {
    // Function for adding one to the number represented by the array
    Vector<Integer> addOne(int[] arr) {
        int n = arr.length;
        int i = n - 1;
        
        // Step 1: Handle carry if digits are 9
        while (i >= 0 && arr[i] == 9) {
            arr[i--] = 0;
        }
        
        // Step 2: All digits were 9
        if (i < 0) {
            Vector<Integer> v1 = new Vector<>(n + 1);
            v1.add(1);
            for (int j = 0; j < n; j++) {
                v1.add(arr[j]);
            }
            return v1;
        }
        // Step 3: Increment the non-9 digit
        else {
            arr[i]++;
        }
        
        // Step 4: Convert to Vector for return
        Vector<Integer> v1 = new Vector<>(n);
        for (int j = 0; j < n; j++) {
            v1.add(arr[j]);
        }
        return v1;
    }
}


â± Complexity Analysis
Time Complexity: O(n) â³ â€” We may touch each digit once in the worst case (all 9's).

Space Complexity: O(1) ğŸª¶ â€” No extra space except the result vector (constant extra space if no new digit).

ğŸ“Œ Key Points
âœ… Works for both small and very large numbers represented as arrays.

âœ… Handles carry propagation properly.

âœ… Creates a new number if the size increases (e.g., 999 â†’ 1000).

âœ… Works in in-place fashion if possible.

âœ¨ Tip: This is a classic carry-handling problem and often appears in interview coding rounds.
