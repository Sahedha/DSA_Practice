# Alternate Positive & Negative Numbers

## 📝 Problem Statement
Given an **unsorted array** `arr` containing both positive and negative numbers,  
your task is to **rearrange the array** such that it contains **alternate positive and negative numbers** without changing their **relative order**.

---

## 📌 Rules
1. The resulting array should **start with a positive integer** (`0` is also considered positive).  
2. If one type of integer (positive/negative) gets exhausted, append the remaining integers as they are (while maintaining order).  
3. The array may or may not have equal counts of positive and negative integers.  

---

## 🔍 Examples

**Example 1:**
Input: arr = [9, 4, -2, -1, 5, 0, -5, -3, 2]
Output: [9, -2, 4, -1, 5, -5, 0, -3, 2]

Explanation:
Positives = [9, 4, 5, 0, 2]
Negatives = [-2, -1, -5, -3]
We place alternately → 9 (pos), -2 (neg), 4 (pos), -1 (neg)...

**Example 2:**
Input: arr = [-5, -2, 5, 2, 4, 7, 1, 8, 0, -8]
Output: [5, -5, 2, -2, 4, -8, 7, 1, 8, 0]

Explanation:
Positives = [5, 2, 4, 7, 1, 8, 0]
Negatives = [-5, -2, -8]
After -8, no negatives left → append remaining positives.


**Example 3:**
Input: arr = [9, 5, -2, -1, 5, 0, -5, -3, 2]
Output: [9, -2, 5, -1, 5, -5, 0, -3, 2]


---

## ✅ Constraints
- `1 ≤ arr.size() ≤ 10^6`  
- `-10^6 ≤ arr[i] ≤ 10^6`  

---

## 💡 Approach
1. Separate the array into two lists:  
   - `pos` → stores all positive numbers (including `0`).  
   - `neg` → stores all negative numbers.  
2. Traverse both lists and **place elements alternately** into the original array.  
3. If any list has leftover elements, append them at the end (while keeping order intact).  

This ensures relative order is preserved ✅.

---

##  Solution 1 -- 🧑‍💻 Code (Java)

```java
// User function Template for Java
class Solution {
    void rearrange(ArrayList<Integer> arr) {
        int n = arr.size();

        ArrayList<Integer> pos = new ArrayList<>();
        ArrayList<Integer> neg = new ArrayList<>();

        // Step 1: Separate positives and negatives
        for (int i = 0; i < n; i++) {
            if (arr.get(i) >= 0) {
                pos.add(arr.get(i));
            } else {
                neg.add(arr.get(i));
            }
        }

        // Step 2: Merge alternately
        int pind = 0, nind = 0, ind = 0;
        while (pind < pos.size() && nind < neg.size()) {
            if (ind % 2 == 0) {
                arr.set(ind++, pos.get(pind++));
            } else {
                arr.set(ind++, neg.get(nind++));
            }
        }

        // Step 3: Add remaining positives
        while (pind < pos.size()) {
            arr.set(ind++, pos.get(pind++));
        }

        // Step 4: Add remaining negatives
        while (nind < neg.size()) {
            arr.set(ind++, neg.get(nind++));
        }
    }
}

```
---

### **⏱️ Complexity Analysis**
Time Complexity: O(n) → one traversal to separate, one to merge.

Space Complexity: O(n) → extra lists pos[] and neg[] to maintain order.

---

### **🎯 Key Points**
Maintains relative order of positives and negatives.

Always starts with a positive number (or 0).

Works even if positives/negatives count is unequal.

✨ This problem is an example of array rearrangement with order preservation.

---

### **✅ Solution 2: In-Place Approach (Efficient but Not Stable)**

If we don’t care about preserving the original order, we can solve this in-place using O(1) space.

Idea:

Partition array into positives and negatives (like QuickSort partition).

Alternate them by swapping.

---

## code(JAVA)

```java
class Solution {
    void rearrangeInPlace(int[] arr) {
        int n = arr.length;
        int i = -1;
        
        // Partition step: move negatives to one side
        for (int j = 0; j < n; j++) {
            if (arr[j] < 0) {
                i++;
                int temp = arr[i];
                arr[i] = arr[j];
                arr[j] = temp;
            }
        }
        
        int pos = i + 1, neg = 0;
        
        // Rearrange alternately
        while (pos < n && neg < pos && arr[neg] < 0) {
            int temp = arr[neg];
            arr[neg] = arr[pos];
            arr[pos] = temp;
            pos++;
            neg += 2;
        }
    }
}

```
---

## Complexity:

Time: O(n)

Space: O(1)

---

### ⚠️ Drawback: Relative order is not preserved.

---

### 🔎 Which Solution to Use?

If order matters → Use Solution 1 (extra space but stable).

If space optimization matters → Use Solution 2 (in-place but unstable).

---
