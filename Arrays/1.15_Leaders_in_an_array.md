# Array Leaders üëë

**Difficulty:** Easy  

---

## üìå Problem Statement
You are given an array `arr` of positive integers.  
Your task is to find all the **leaders** in the array.  

üëâ An element is considered a **leader** if it is **greater than or equal to all elements to its right**.  
üëâ The **rightmost element** is always a leader.

---

## üìù Examples

### Example 1
**Input:**  
`arr = [16, 17, 4, 3, 5, 2]`  

**Output:**  
`[17, 5, 2]`  

**Explanation:**  
- `17` is greater than all elements to its right.  
- `5` is greater than all elements to its right (`[2]`).  
- `2` is the last element ‚Üí always a leader.

---

### Example 2
**Input:**  
`arr = [10, 4, 2, 4, 1]`  

**Output:**  
`[10, 4, 4, 1]`  

**Explanation:**  
- `10` is greater than everything on its right.  
- Both `4`s are leaders because equal elements on the right are allowed.  
- `1` is the last element ‚Üí always a leader.

---

### Example 3
**Input:**  
`arr = [5, 10, 20, 40]`  

**Output:**  
`[40]`  

**Explanation:**  
- Since the array is strictly increasing, only the last element is a leader.

---

### Example 4
**Input:**  
`arr = [30, 10, 10, 5]`  

**Output:**  
`[30, 10, 10, 5]`  

**Explanation:**  
- Since the array is non-increasing, **every element is a leader**.

---

## üéØ Constraints
- `1 ‚â§ arr.size() ‚â§ 10^6`  
- `0 ‚â§ arr[i] ‚â§ 10^6`  

---

## üí° Approach

1. Start from the **rightmost element** (always a leader).  
2. Keep track of the **maximum element from the right (mRt)**.  
3. Traverse the array from right ‚Üí left:
   - If `arr[i] >= mRt`, then `arr[i]` is a **leader**.  
   - Update `mRt`.  
4. Since leaders are collected in reverse order, **reverse the list** at the end.

---

## ‚úÖ Code (Java)

```java
import java.util.*;

class Solution {
    static ArrayList<Integer> leaders(int arr[]) {
        int n = arr.length;
        ArrayList<Integer> res = new ArrayList<>();
        
        // Rightmost element is always a leader
        int mRt = arr[n - 1];
        res.add(mRt);
        
        // Traverse from right to left
        for (int i = n - 2; i >= 0; i--) {
            if (arr[i] >= mRt) {
                mRt = arr[i];
                res.add(mRt);
            }
        }
        
        // Reverse to restore left-to-right order
        Collections.reverse(res);
        return res;
    }
}

```
---

### **‚è±Ô∏è Complexity Analysis**
## Time Complexity: O(n)

We make one traversal of the array.

Reversing the result list also takes O(n).

## Space Complexity: O(n)

We use an extra list to store the leaders.
O(n) in this implementation because we store leaders in a new ArrayList (as required by the problem).

Could be O(1) if the task was only to print leaders instead of storing them.

‚ö° This is optimal and efficient given the constraints (n ‚â§ 10^6).

---

### **üîé Key Takeaways**
Rightmost element is always a leader.

Leaders can be found in one backward pass.

This problem is a great example of using a running maximum technique.
