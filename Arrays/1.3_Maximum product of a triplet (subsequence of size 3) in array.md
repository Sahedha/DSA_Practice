# Three Great Candidates

**Difficulty:** Easy  
**Accuracy:** 16.92%  

---

## Time Complexity
- **O(n)** — Single pass through the array.

## Space Complexity
- **O(1)** — Only constant extra space is used.

---

## Problem Statement
The hiring team wants to pick **3 candidates** whose abilities (given as integers) make the **maximum possible product** when multiplied together.

Given an integer array `arr[]` representing candidates' abilities, return the **maximum product** that can be formed by choosing any three elements from the array.

---

## Examples

**Example 1**
Input: arr[] = [10, 3, 5, 6, 20]
Output: 1200
Explanation: 10 * 6 * 20 = 1200


**Example 2**
Input: arr[] = [-10, -3, -5, -6, -20]
Output: -90
Explanation: -3 * -5 * -6 = -90


---

## Key Idea / Approach

To get the maximum product of three numbers, there are two possibilities to consider (because of negative numbers):

1. **Product of the three largest numbers** (`max1 * max2 * max3`).
2. **Product of the largest number and the two smallest (most negative) numbers** (`max1 * min1 * min2`) — this can be large because two negatives make a positive.

So the answer is:
max( max1 * max2 * max3, max1 * min1 * min2 )

markdown
Copy
Edit

We can find `max1`, `max2`, `max3` and `min1`, `min2` in a single pass over the array in O(n) time, and O(1) extra space.

**Note:** Use a wider integer type (e.g., `long` in Java) while computing products to avoid overflow during intermediate multiplications, then cast to the required type if necessary.

---

## Algorithm (one-pass)
1. Initialize:
   - `maxA`, `maxB`, `maxC` to very small values (for top 3 maximums).
   - `minA`, `minB` to very large values (for 2 minimums).
2. Iterate through each element `x` in `arr`:
   - Update `maxA/maxB/maxC` appropriately if `x` is larger than some of them.
   - Update `minA/minB` appropriately if `x` is smaller than some of them.
3. Compute:
   - `product1 = minA * minB * maxA`  (two smallest negatives and the largest positive)
   - `product2 = maxA * maxB * maxC`  (three largest)
4. Return the larger of `product1` and `product2`.

---

## Java Implementation

```java
class Solution {
    int maxProduct(int[] arr) {
        int n = arr.length;
        
        long maxA = Integer.MIN_VALUE, maxB = Integer.MIN_VALUE, maxC = Integer.MIN_VALUE;
        long minA = Integer.MAX_VALUE, minB = Integer.MAX_VALUE;

        for (int i = 0; i < n; i++) {
            int x = arr[i];

            // Update top 3 maximums
            if (x > maxA) {
                maxC = maxB;
                maxB = maxA;
                maxA = x;
            } else if (x > maxB) {
                maxC = maxB;
                maxB = x;
            } else if (x > maxC) {
                maxC = x;
            }

            // Update bottom 2 minimums
            if (x < minA) {
                minB = minA;
                minA = x;
            } else if (x < minB) {
                minB = x;
            }
        }

        long prod1 = minA * minB * maxA; // two negatives + largest positive
        long prod2 = maxA * maxB * maxC; // three largest positives
        return (int) Math.max(prod1, prod2);
    }
}


Edge Cases
Array length less than 3 → usually undefined; depends on platform requirements.

Handles negative numbers correctly (two negatives can make a large positive).

Uses long to avoid intermediate overflow, final result cast to int if needed.

Sample Test Cases
Mixed positives:

arr = [10, 3, 5, 6, 20]  -> 1200
All negatives:

arr = [-10, -3, -5, -6, -20] -> -90
Negative and positive mix:

arr = [-10, -10, 5, 2] -> 500   (because -10 * -10 * 5 = 500)
