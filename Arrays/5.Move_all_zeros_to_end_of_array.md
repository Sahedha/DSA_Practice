# ğŸš€ Move All Zeroes to End

**Difficulty:** ğŸŸ¢ Easy  
**Accuracy:** ğŸ“Š 45.51%  

---

## ğŸ“œ Problem Statement
You are given an array `arr[]` of **non-negative integers**.  
Your task is to **move all the zeros** in the array to the **right end** while maintaining the **relative order** of the non-zero elements.  

âš ï¸ **Note:** The operation must be **in-place** (no extra array allowed).

---

## ğŸ“‚ Examples

**Example 1**  
Input:  
arr[] = [1, 2, 0, 4, 3, 0, 5, 0]

Output:  
[1, 2, 4, 3, 5, 0, 0, 0]

âœ… **Explanation:** There are three `0`s that are moved to the end.

---

**Example 2**  
Input:  
arr[] = [10, 20, 30]

Output:  
[10, 20, 30]

âœ… **Explanation:** No change as there are no `0`s.

---

**Example 3**  
Input:  
arr[] = [0, 0]

Output:  
[0, 0]

âœ… **Explanation:** All are zeros, so the array remains the same.

---

## ğŸ“ Constraints
- `1 â‰¤ arr.size() â‰¤ 10^5`  
- `0 â‰¤ arr[i] â‰¤ 10^5`

---

## ğŸ›  Approach
1. **Count pointer:** Maintain a variable `count` to track the index where the next non-zero element should be placed.  
2. **First pass:** Traverse the array and copy all **non-zero** elements to the front (using `count`).  
3. **Second pass:** Fill the rest of the array with zeros starting from `count` to the end.  
4. **In-place:** No extra array is used â€” everything happens within the same array.

---

## ğŸ’» Code Implementation (Java)
```java
class Solution {
    void pushZerosToEnd(int[] arr) {
        int count = 0;
        for(int i = 0; i < arr.length; i++) {
            if(arr[i] != 0) {
                arr[count++] = arr[i];
            }
        }
        while(count < arr.length) {
            arr[count++] = 0;
        }
    }
}


â± Time Complexity
O(n) â€” We traverse the array twice (but both passes are linear).

ğŸ’¾ Space Complexity
O(1) â€” No extra space is used.

âœ¨ Key Points
âœ” Maintains the relative order of non-zero elements.

âœ” Works in-place without extra space.

âœ” Handles edge cases like all zeros or no zeros efficiently.

ğŸ¯ Summary
This problem teaches in-place array manipulation â€” a crucial technique for optimizing space in algorithms.
Mastering such problems improves skills in two-pointer techniques and efficient iteration.

---
